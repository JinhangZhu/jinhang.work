---
title: "华为2019校招经历"
date: 2019-11-30T22:18:51+01:00
categories: [Life,Thoughts]
tags: ["Recruitment"]
slug: "huawei-recruitment-interview-experience"
---

本文记录了我申请华为从机考到面试的过程。<!--more-->

# 结果

>2020-01-10

通过。太感谢华为的赏识了。因为时差，大家都在晚上八九点还在面试，辛苦了！

# 综面

> 2020-12-10

各种各样的问题，基本上就是按照简历来的，也明白了有很多经历我自己都没好好总结，好好思考，借助这次机会回顾了一下。

# 性格测评经历

> 2019-11-30

在Queens Building的大厅内，我完成了我的华为网上测评，没有很激动。<!--more-->同上次机考经历不同，这次的考试经历给我带来了更多的不确定性。一共36道职业态度题，每道题又分成了几个小题，小题的选项从非常不同意到非常同意，然而我并没有做得特别自信和轻松，我难得的陷入了对自己深深的反思中：我是这样的人吗，我好像是欸那就选它吧......欸这道题里面，和其他选项比较，我好像不太是这样的人啊？？？那刚刚选错了啊也改不了了😑......到了后面某道题，嗯？我好像刚刚觉得的性格又不是很有优势啊？我是为了迎合岗位要求而填呢还是按照刚刚选择的“真实”自我判断来填呢？不对啊，我这个判断是否准确呢？就这样，我度过了短暂而又漫长的几十分钟。

现在看来，我选择的大部分职业性格及其程度应该是自己实际性格的近似，小部分是自己目前不是但是有很强的冲动去适应的目标。虽然有些地方前后矛盾，但是我觉得，这样的一次测评更好地帮助我认识自我，重塑自我。

从前我以为，性格测试真的就是小儿科，做那么十几道题就能决定我在古代适合当李白了？（打个小比方）。那说明我还没有碰到真正专业的测试系统，这回碰上了，蹭了一鼻子灰，才知道自己对自己的精神层面的认识确实不够。

这也体现出来做事的专业性的重要性，小打小闹的仅供娱乐，要汲取经验，学到本领还是得靠专业的东西。此次测评就是个很好的例子，希望结果不错，继续努力！

![2019-11-30.png](https://i.loli.net/2019/11/30/oABhcfVYFsmDJXz.png)



# 技术面试经历

> 2019-12-04

今天（实际上是前天）经历了两轮技术面，概括来说特点是**氛围轻松，手写代码如履薄冰**。<!--more-->

面试之前花了一天和半个上午进行了面试的准备，这里要特别感谢我的好朋友SBR给了我技术面的很多建议。根据这些建议和网上的一些经验总结，我大概遵从了这样的准备过程：

1. 项目经历中的技术点细节，自己负责的工作细节；
2. 一些常见的算法（因为时间不太够，也只能抱抱佛脚了）；
3. 《剑指Offer》面试要点；
4. 自我介绍怎么说。

这样的准备基本上都概括到了，除了算法这样看重平时积累的部分只求尽量看多一点。实际的面试过程中，两位面试官对项目经历问得非常多，并且在技术点基础上也换着方式问我问题，如“感觉最有挑战性的项目是哪一个？”，“你在这个项目里，碰到了哪些难点？”等。

### 武汉的面试官

第一轮面试官是来自武汉的部门，问了我项目细节，听到我说会做一些计算机视觉的python编程后问我“我们做自动化测试时，有的平板或者PC屏幕中会出现一些像素点的问题，常常会变黑，如果让你让你设计算法检测出这样的故障，你会怎么做？”。我当时在前辈话还没说完就想到了膨胀操作，但是说完之后也没想到更好的方法，就直接回答我目前能想到的方法是：相机拍照，去掉边框截取屏幕区域，进行图像膨胀操作，让小黑点变得明显（之后通过定位计数等操作，这个我没说，还是稍有紧张，思路不完整），以此来检测此类屏幕故障。

前辈也考了我一道手写代码题：*找出一个正整数数组中的第二大的数*。

前辈开始以为我主C++，在我表明自己目前不擅长而且用C++写不出来，只能用python情况下，同意我使用python写代码。我也问了这个程序的输入是空格隔开吗？前辈说可以就写一个函数，输入参数为正整数数组。

那我的思路是：

- 解决找次大数的算法。这个好说，函数里先找到最大的数，删掉（`input_list.remove(max_value)`，😓我当时把`remove`记成`delete`了）。

- 其次加入故障检测。这个是《剑指Offer》教的一个好习惯，编程要习惯对非法输入进行检测并报错。我能想到了检测器就是：判断数组（list）中是否有元素不是正整数，判断条件是要大于0以及本身或者减一可以被2整除。符合要求就继续删除最大值，找到删除之后list最大值并返回这个值；不符合要求就输出错误信息并返回None。

  > 这个检测可能不是最好办法，但是有效。减小时间复杂度还要看有没有优化办法。

- 必要的注释。

### 东莞的面试官

这位前辈也问了我很多技术细节（主要针对点光源追踪，因为我回答说这是最能体现我能力的项目，结合了自动控制和信号处理），也问了我做项目时感觉到的难点，我回答是实现PID算法和调参。

中间很多经历我记得不是很清楚了，直接介绍代码题：找出100000以内所有的质数，要求时间复杂度最小。

惭愧...... 和我机考第三题（输入正整数，判断是否是素数）一样，可是我上次总结的时候，就写道没有达到最小时间复杂度，然后也没有进行训练实现。这次考到了，我心想，大概是凉了。不过我表面也没有慌，还是边写上次的算法边想能不能在十分钟之内想出最优解。事实是没有。

那么我的算法还是使用`sqrt`函数来缩小遍历范围。设计函数，默认输入参数为`n = 100000`，创建空list，两层循环，第一层对2-n遍历，第二层遍历范围是`2,int(math.sqrt(iter_num))+1`，判断第一层循环索引能否被第二层索引整除，不是就说明第一层索引不是素数。找到素数就加入list，最后函数返回这个list。

### 结果

（更新）面试第二天收到了HR的信息，说准备综合面试，商量时间。这才觉得技术面试是过去了，还有一轮综合面试，风险也不小，继续加油！



# 软件题机考经历

> 2019-11-27

今天参加了华为2019届校招的软件题机考，一共三道编程题，最后结果是前两道题ac了，最后一道题提示tle了，测试例子只有60%通过率。<!--more-->总体来说感觉难度应该不大（尤其是我只复习了三天，两天复习python和算法，一天学习新知识数据结构结果不考），如果我准备得更早，一定会有更大的把握。其次是这次没有考动态规划算法，我在复习的最后时刻才知道有这个算法，看了不到半小时毫无思路，干脆放弃，硬着头皮开始考试。

> 以后加大力度刷算法题🔨

现在离考试结束已经过去两个多小时了，我大概回忆一下三道编程题内容。

## 1 找两倍关系

### 1.1 题目描述

首先输入一个正整数表明接下来输入正整数的组数，然后先输入这一组正整数个数，再输入多个正整数，每一组正整数用空格隔开，如果有正整数`x`是其他正整数的两倍，那么输出这一组中所有这样的`x`的个数。

如输入：

```
2
5
1 3 5 7 9
2 4 6 8 10
```

输出：

```
0
2
```

### 1.2 解题思路

既然找两倍关系，我思考只要另建一个list保存两倍的原list，然后用set转换类型，利用set的交集&来形成x的set，取出长度输出。

> 不过现在我想，这个方法如果碰到多个同样的x怎么办，set类型转换就只保留一个了，这样还ac了说明测试例子的正整数都是不同值的。

### 1.3 代码

```python
nGroup = int(input())
for i in range(nGroup):
    lenGroup = int(input())
    line = list(map(int, input().split()))
    group = line[0:lenGroup]
    twiceGroup = []
    for i, x in enumerate(group):
        twiceGroup.append(x*2)
    setTwice = set(twiceGroup)
    setOrig = set(group)
    intersection = setOrig & setTwice
    print(len(intersection))
```

## 2 回文进制

### 2.1 题目描述

输入十进制数字`N`，转换为`r`进制，如果`r`进制数是回文数，则输出`r`，`r`范围是[2,16]；如果对于所有进制都不存在回文，则输出`-1`。

如输入`30`

九进制数和十四进制数分别是33和22，都是回文数，则输出

```
9
14
```

> 回文：正向和反向读的序列一样，如17371，414，88等。

### 2.2 解题思路

我思考需要有两个主要函数：**进制转换**和**回文判断**。既然目的是判断，那我就直接对list操作就行，不需要转换成整数型。对所有r遍历，如果生成了回文，直接输出r，遍历结束也没有回文则输出-1。

**进制转换**：输入参数为十进制数和进制，采用除法产生一级级位数（商），除数作为下一级的被除数，将位数依次存入list，函数返回list之后要翻转才是正确结果。

> 现在看，考虑我们只需要判断回文，正序逆序都没差，不翻转也没事。

如：

```
2	|30		0
2	|15		1
2	|7		1
2	|3		1
	1
OUTPUT: 01111
Reverse: 11110
```

**回文判断**：对进制数位数奇偶性分别分析，注意特殊情况：长度为一。

🔨**注意**：

- 长度为1的特殊情况：全是回文数；
- list的切片，[start:end]实际上不包括end，留头不留尾。

### 2.3 代码

```python
def rTrans(num, r):
    rResult = []
    rest = num
    while True:
        if rest < r:
            rResult.append(rest)
            break
        digit = rest % r
        rest = rest//r
        rResult.append(digit)
    return rResult


def isConsistant(alist):	#回文是palindrome，我刚刚不知道才写consistant
    n = len(alist)
    if n % 2 == 0:
        half_1 = alist[0:n//2]
        half_2 = alist[n//2:n]
        return half_1 == half_2[::-1]
    elif n == 1:
        return True
    else:
        half_1 = alist[0:(n-1)//2]
        half_2 = alist[(n+1)//2:n]
        return half_1 == half_2[::-1]


if __name__ == "__main__":
    num = int(input())
    noConsis = True
    for r in range(2, 17):
        trans = rTrans(num, r)
        trans.reverse()
        isConsis = isConsistant(trans)
        if isConsis:
            print(r)
            noConsis = False
    if noConsis:
        print(-1)
```

## 3 对素数情有独钟

### 3.1 题目描述

商店在顾客购物第几天就有几项商品。有一位顾客只在素数天（第2天，第3天，第5天......）购物，如果在第`j`素数天时，第`i`次购物，可供选择的只有价格序列的前`j`项，而顾客只会买第`i`便宜的商品，要输出在`M`天内顾客的总消费。

比如，输入天数和这些天的价格：

```
11
10 20 30 10 5 11 12 15 16 17 21
```

那么购买情况为：

- 第2天，第一次购物，价格序列[10,20]，消费10；
- 第3天，第二次购物，价格序列[10,20,30]，消费20；
- 第5天，第三次购物，价格序列[10,20,30,10,5]，消费10；
- 第7天，第四次购物，价格序列[10,20,30,10,5,11,12]，消费11；
- 第11天，第五次购物，价格序列[10,20,30,10,5,11,12,15,16,17,21]，消费12；

输出总消费为

```
63
```

**🔨注：题目专门说明，时间复杂度为$ \mathcal{O}(n^2)$的算法可能会超时。**

> 那么我的算法确实在40%的测试中超时了，暂时还不知道如何改进。

### 3.2 解题思路

根据任务分函数：**判断素数**和**找到单日消费**。遍历天数，在素数天中找出当日价格，对所有消费求和输出即可。但此题重点应该是不超时，降低**时间复杂度**。

**判断素数**：如果n不能被从2到$int(\sqrt{n}+1)$的任何正整数整除就算素数。

> 如果一次性找到n以内的所有素数会不会更快呢？我试了没用。

**找到单日消费**：先对价格序列切片，切片序列排序找到第`i`低的价格返回。

### 3.3 代码

```python
import math


def is_prime(num):
    end = int(math.sqrt(num))
    isPrime = True
    for x in range(2, end+1):
        if num % x == 0:
            isPrime = False
            break
    if isPrime and num != 1:
        return True


def find_price(j, primeday, priceList):
    slicePrice = priceList[0:primeday]
    slicePrice.sort()
    return slicePrice[j-1]


if __name__ == "__main__":
    M = int(input())
    priceList = list(map(int, input().split()))
    prime_list = []
    for i in range(1, M+1):
        if is_prime(i):
            prime_list.append(i)
    sumPay = 0
    count = 1
    for i in prime_list:
        pay_this_day = find_price(count, i, priceList)
        sumPay += pay_this_day
        count += 1
    print(sumPay)
```

